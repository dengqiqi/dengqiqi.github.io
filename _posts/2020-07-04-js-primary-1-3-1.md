---
title: 【JS知识体系：1-3-1】闭包和作用域
date:  2020-07-04 11:59:21 +0800
category: 前端
tags: ['JS', 'JS基础知识']
excerpt: 闭包是js中的重难点，必须要完全掌握。
---

# 闭包和作用域

> **前言：** 如果现在和过去能建立联系，我是否可以穿越回去改变什么。闭包真让人羡慕。



要想理解闭包，首先我们要搞清楚什么是作用域



## 1. 作用域和作用域链

作用域本质上是一个对象，里面保存着当前运行环境所有声明的全部变量和函数。

作用域分为

* 全局作用域
* 函数作用域
* 块级作用域（ES6新增）

当js引擎开始运作的时候，它首先加载到内存的是当前ECMAScript实现的宿主环境，这样一个宿主环境就是全局环境或者说全局作用域，在WEB浏览器中全局作用域即为window对象，而在node中，全局作用域即为golbal，



函数作用域，函数作为特殊的对象，它具有可声明和可调用的特性，调用即执行函数中的语句(指令)，那么在调用函数的时候，系统会创建一个新的运行环境，这个运行环境就是函数作用域。



块极作用域，一个{}包裹住的代码叫作一个块，ES6以前并没有块极作用域，即解析器执行到{}时不会开辟新的运行环境。ES6之后，使用let和const都会创建块极作用域



## 1.1 变量提升

系统开辟了运行环境之后，js解析器第一件事并不是开始一条一条执行指令了，而是先找出所有var关键字声明的变量，或者function关键字声明的函数（本质仍是一个变量）,找到后，首先将这些变量的标识存到当前作用域中，即先统一存键，执行到代码的时候再存值，

```js
log(a); // dundefined，不会报错
var a = 1;
log(a); // 1
```

思考一下下面代码的执行结果

```js
log(a); // error
a = 1;
log(a);
```

```js
fn();
log(a); // 1
function fn(){
  a = 1;
}
```

```js
fn();
log(a); // error
function fn(){
  var a = 1;
}
```

当遇到函数声明的时候，除了要保留函数名外，还要另外预备一个内存空间，这个空间引用null，为了今后函数调用的时候载入函数作用域。



## 1.2 作用域链

变量(含函数)的作用域是在声明的时候就决定了，当我们在函数内部访问一个变量，这个变量如果没有定义，就会去它的父级作用域上去查找，如果还是查找不到，就到父级的父级作用域上去查找，直到全局作用域还是没有找到的话，就会抛出一个错误。这种作用域间的关系就叫作作用域链。那么对于一个函数作用域而言，其父级作用域是什么呢？答案是取决于这个函数声明时所在的作用域而非调用时的作用域。

```js
var a = 1;

function fn1() {
  var a = 2;
  var b = 10;
  fn2();
}
function fn2() {
  log(a);
  // log(b) 如果执行会报错
}
fn1(); // 1
```

```js
var a = 1;

function fn1() {
  var a = 2;
  var b = 10;
  fn2();
  function fn2() {
    log(a);
    log(b);
  }
}

fn1(); // 2, 10
```



## 2. 闭包

来自《JavaScript高级程序设计》和百度百科中的定义是：

**闭包就是有权访问另一个函数中变量的函数!**

来自《javaScript权威指南》中的定义：

**函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内。这种特性在计算机科学文献中称为“闭包”**

来自ECMAScript中的定义是：

**闭包，指的是词法表示包括不被计算的变量的函数，也就是说，函数可以使用函数之外定义的变量。**



看了这些定义，总结一下似乎在说，闭包是函数的特性，函数可以访问函数外的变量。

刚刚说了，变量的查找是从作用域的前端往后端查找，只能由内到外访问。

那既然是特性，如何实现函数外部访问函数内部的变量呢？

思路，函数内部返回一个函数，通过外部调用该函数访问

```js
function outer() {
  var a = 'outer内部变量';
  
  return function inner() { // 这里可以直接用匿名函数，这里是为了接下来讲解方便
    console.log(a);
  }
}

var outermost = outer(); // ★
outermost(); // outer内部变量
```

这里其实和作用域链的访问机制并不冲突，它仍然是从内向外访问。

**这样做本质是达到了一个什么效果呢？**

这个问题需要先了解一下js的内存管理和垃圾回收的知识了

以下链接是MDN上内存管理的教程：

[查看教程](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management)

上面教程里提到了一个概念，**引用**，

> 在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。例如，一个Javascript对象具有对它[原型](https://developer.mozilla.org/en/JavaScript/Guide/Inheritance_and_the_prototype_chain)的引用（隐式引用）和对它属性的引用（显式引用）。
>
> 在这里，“对象”的概念不仅特指 JavaScript 对象，还包括函数作用域（或者全局词法作用域）。

垃圾回收算法就是依赖引用的概念，此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。

但是该算法有一个限制，就是无法处理循环引用的事例。

于是有了**标记-清除算法**

> 这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。
>
> 这个算法假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。
>
> #### 限制: 那些无法从根对象查询到的对象都将被清除

在上面例子中，声明outer函数的时候，相等于在outer函数内部作用域中声明了一个对outermost作用域的引用，此时没有真正的引用，只是一个null，告诉解析器即将引用。当outer()执行的时候，才是outer作用域真正引用outermost作用域的时候，按道理讲outer函数执行完后，这个引用又会置为null，从而回收outer的作用域(内有a变量对应的内存)，我们不可能再访问的到outer作用域。

但是上面的例子实际上，outer函数内部返回了一个新的函数，即声明了一个新的函数作用域，这个作用域引用outer的作用域，这个新的inner函数作用域在执行打星号行的时候又被outermost作用域所引用，因为outermost作用域是我们的根(全局作用域)，并且通过根可以访问到outer和inner。

所以上面例子达到的一个效果就是，outer函数作用域无法释放内存，我们可以通过这条**循环的作用域链**来访问该链上任意的变量。

这个功能某些时候是很强大的，但是它的弊端却比它的作用先暴露了出来，那就是消耗内存。

如何解决消耗内存的问题呢？这就需要我们手动打破作用域链的循环，将``outermost = null``，即从根无法再找到它。



接下来来看一个利用闭包实现的计数器应用

```js
function counter() {
  var a = 0;

  return {
    counter: function() {
      a++;
    },
    reset() {
      a = 0;
    },
    getValue() {
      console.log(a);
      return a;
    }
  }
}

var c1 = counter();
var c2 = counter();

c1.counter();
c1.counter();
c1.counter();
c1.getValue(); // 3
c1.reset();
c1.getValue(); // 0
c1.counter(); 
c1.getValue(); // 1

var c2 = counter();
c2.counter();
c2.counter();
c2.counter();
c2.counter();
c2.getValue(); // 4

c1.counter();
c1.getValue(); // 2
```

这里我们创建了两个计数器c1和c2，第一个计数器的执行结果情理之中，关键在于c2计数器的执行结果，为什么打印的不是5而是4呢，c1和c2之间为什么可以互相不干扰呢？

**因为每一次函数调用都会创建一个新的运行环境，即使调用的是同一个函数，并且上一次的调用创建的环境还在。**

那么上面的代码实际上相当于一个生产定时器的工厂函数，并且生产出来的每个定时器只能通过getValue接口拿到他里面的值。是不是很棒。



黑白分明，再来看一个糟糕的场景

```js
function count() {
  var arr = [];
  for (var i=1; i<=3; i++) {
      arr.push(function () {
          return i * i;
      });
  }
  return arr;
}

var results = count();
var f1 = results[0];
var f2 = results[1];
var f3 = results[2];


log(f1(), f2(), f3()) // 16 16 16
```

看到这里你可能会问，什么鬼？为啥不是1,4,9嘞？

是的，我们的本意是想要输出1,4,9，但是由于js没有块级作用域，所以i这个变量是保存在count这个函数作用域中，当我们调用函数去访问count内的i时，count内的代码早已执行完，并保存的i值为4

好了，我们把上面的变个形再考察一下。

```js
function count() {
  var arr = [];
  for (var i=1; i<=3; i++) {
      arr.push(function () {
          return ++i;
      });
  }
  return arr;
}

var results = count();
var f1 = results[0];
var f2 = results[1];
var f3 = results[2];


log(f1(), f2(), f3())
```

相信有了上面的经验之后，你肯定不会再说结果是2 ,3, 4了。

有可能有人就会说，答案是5, 5, 5

哈哈，实际打印的结果是5, 6, 7。这才是正确答案。

看到这里你可能又要问，这又是什么鬼？说好的函数每次调用都会创建新的作用域，互不干扰的呢？

这里需要看清楚，i变量是存在在count函数作用域中，而不是存在在内部的匿名函数作用域中，而count函数我们只调用了一次，所以i变量对于f1, f2, f3是共享的。



上面两个例子如果我们想实现块级作用域的效果，该如何做呢？

很简单，我们只需要再包裹一层函数用来模拟块级作用域就好了

```js
function count() {
  var arr = [];
  for (var i=1; i<=3; i++) {
      arr.push(
        (function(i){
          return function () {
            return ++i;
          }
        })(i)
      );
  }
  return arr;
}

var results = count();
var f1 = results[0];
var f2 = results[1];
var f3 = results[2];


log(f1(), f2(), f3())
```



先讲到这吧。

