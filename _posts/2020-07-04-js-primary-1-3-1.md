---
title: 【JS知识体系：1-3-1】闭包和作用域
date:  2020-07-04 11:59:21 +0800
category: 前端
tags: ['JS', 'JS基础知识']
excerpt: 闭包是js中的重难点，必须要完全掌握。
---

# 闭包和作用域

> **前言：** 如果现在和过去能建立联系，是否可以穿越回去改变什么。闭包真让人羡慕。



要想理解闭包，首先我们要搞清楚什么是作用域



## 1. 作用域和作用域链

作用域本质上是一个[[scope]]对象，里面保存着当前运行环境所有声明的变量和函数。

作用域分为

* 全局作用域
* 函数作用域
* 块级作用域（ES6新增）

当js引擎开始运作的时候，它首先加载到内存的是当前ECMAScript实现的宿主环境，这样一个宿主环境就是全局环境，这个全局环境即全局上下文，全局上下文在调用栈中只有唯一的一个。全局上下文在调用的时候，会创建一个[[scope]]对象，里面包含了全局对象挂载的所有属性和方法，这样的一个[[scope]]对象叫作全局作用域。

在WEB浏览器中全局作用域即为window对象，而在node中，全局作用域即为golbal。



函数作用域，函数作为特殊的对象，它具有可声明和可调用的特性，调用即执行函数中的语句(指令)，调用函数会创建一个新的函数上下文环境，然后推入调用栈中；那么在调用函数的时候，也会创建一个[[scope]]对象，保存函数中声明的所有变量和函数，这个[[scope]]对象叫作函数作用域。



块极作用域，一个{}包裹住的代码叫作一个块，ES6以前并没有块极作用域，即解析器执行到{}时不会开辟新的上下文环境。ES6之后，使用let和const都会创建块极作用域



## 1.1 执行上下文

上面提到了一个重要的概念，就是执行上下文。我们来看看一个执行上下文都做了些什么。

执行上下文的生命周期：

**创建 => 执行 => 回收**

首先是创建阶段，创建阶段主要做了三件事：

1. **创建变量对象**：首先初始化函数的参数 arguments，提升函数声明和变量声明。
2. **创建作用域链**（Scope Chain）：在执行上下文的创建阶段，作用域链是在变量对象之后创建的。作用域链本身包含变量对象。作用域链用于解析变量。当被要求解析变量时，JavaScript 始终从代码嵌套的最内层开始，如果最内层没有找到变量，就会跳转到上一层父作用域中查找，直到找到该变量。
3. **确定 this 指向**：包括多种情况，下一篇文章会详细说明



## 1.2 变量提升

js解析器第一件事并不是开始一条一条执行指令了，而是先找出所有var关键字声明的变量，或者function关键字声明的函数）,找到后，首先将这些变量的标识存到当前作用域中，即先统一存键，执行到代码的时候再存值，

```js
log(a); // dundefined，不会报错
var a = 1;
log(a); // 1
```

思考一下下面代码的执行结果

```js
log(a); // error
a = 1;
log(a);
```

```js
fn();
log(a); // 1
function fn(){
  a = 1;
}
```

```js
fn();
log(a); // error
function fn(){
  var a = 1;
}
```

要注意的是，如果有变量和函数重名，函数提升优先级高于变量提升，看下面代码的执行结果。

```js
log(a); // ƒ a() {}
var a = 1;
function a() {}
```

```js
log(a); // ƒ a() {}
function a() {}
var a = 1;
```

```js
function a() {}
var a = 1;
log(a); // 1
```

```js
var a = 1;
function a() {}
log(a); // 1
a(); // error Uncaught TypeError: a is not a function
```

```js
var a;
function a() {log(a)}
log(a); // ƒ a() {log(a)}
a(); // ƒ a() {log(a)}
```





## 1.3 作用域链

变量的作用域是在声明的时候就决定了，当我们在函数内部访问一个变量，这个变量如果没有定义，就会去它的父级作用域上去查找，如果还是查找不到，就到父级的父级作用域上去查找，直到全局作用域还是没有找到的话，就会抛出一个错误。这种作用域间的继承关系就叫作作用域链。那么对于一个函数作用域而言，其父级作用域是什么呢？答案是取决于这个函数声明时所在的作用域而非调用时的作用域。

```js
var a = 1;

function fn1() {
  var a = 2;
  var b = 10;
  fn2();
}
function fn2() {
  log(a);
  // log(b) 如果执行会报错
}
fn1(); // 1
```

```js
var a = 1;

function fn1() {
  var a = 2;
  var b = 10;
  fn2();
  function fn2() {
    log(a);
    log(b);
  }
}

fn1(); // 2, 10
```



## 1.4 内存回收

以下链接是MDN上内存管理的教程：

[查看教程](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management)

上面教程里提到了一个概念，**引用**，

> 在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。例如，一个Javascript对象具有对它[原型](https://developer.mozilla.org/en/JavaScript/Guide/Inheritance_and_the_prototype_chain)的引用（隐式引用）和对它属性的引用（显式引用）。
>
> 在这里，“对象”的概念不仅特指 JavaScript 对象，还包括函数作用域（或者全局词法作用域）。

垃圾回收算法就是依赖引用的概念，此算法把“对象是否不再需要”简化定义为“**对象有没有其他对象引用到它**”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。

但是该算法有一个限制，就是无法处理循环引用的事例。

于是有了**标记-清除算法**

> 这个算法把“对象是否不再需要”简化定义为“**对象是否可以获得**”。
>
> 这个算法假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。
>
> #### 限制: 那些无法从根对象查询到的对象都将被清除



总结一下，执行上下文在创建之后，推入调用栈执行并做上标记，执行结束之后弹出调用栈，等待回收。回收器开始回收的时候看到该标记，然后从调用栈的根开始查找，如果没有找到，即不在调用栈中，就释放该上下文的内存。



## 2. 闭包

来自《JavaScript高级程序设计》和百度百科中的定义是：

**闭包就是有权访问另一个函数中变量的函数!**

来自《javaScript权威指南》中的定义：

**函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内。这种特性在计算机科学文献中称为“闭包”**

来自ECMAScript中的定义是：

**闭包，指的是词法表示包括不被计算的变量的函数，也就是说，函数可以使用函数之外定义的变量。**



看了这些定义，总结一下似乎在说，闭包是任何函数都有的特性，即函数可以访问函数外的变量。

刚刚说了，变量的查找是从作用域的前端往后端查找，只能由内到外访问。

那既然是特性，如何实现函数外部访问函数内部的变量呢？

一种思路是，函数内部返回一个函数，通过外部调用该函数访问

```js
function outer() {
  var a = 'outer内部变量';
  
  return function inner() { // 这里可以直接用匿名函数，这里是为了接下来讲解方便
    console.log(a);
  }
}

var outermost = outer(); // ★
outermost(); // outer内部变量
```

这里其实和作用域链的访问机制并不冲突，它仍然是从内向外访问。

**为什么会有这种效果呢？**

**因为这种操作实际创建了一条作用域环链。**



在上面例子中，调用outer函数的时候，相等于在outer函数内部作用域中声明了一个对outermost作用域的引用。按道理讲outer函数执行完后，outer的执行上下文出栈，引用关系也就切断了，之后会由回收机制自动回收outer的上下文，我们不可能再访问的到outer作用域。

但是上面的例子实际上，outer函数内部返回了一个新的函数，即声明了一个新的函数作用域，这个作用域引用outer的作用域，这个新的inner函数作用域在执行打星号行的时候又被outermost作用域所引用，因为outermost作用域是我们的根(全局作用域)，即回收机制可以通过根访问到inner然后访问到outer。

所以上面例子达到的一个效果就是，outer函数作用域无法释放内存，我们可以通过这条**循环的作用域链**来访问该链上任意的变量。

这个功能某些时候是很强大的，但是它的弊端却比它的作用先暴露了出来，那就是消耗内存。

如何解决消耗内存的问题呢？这就需要我们手动打破作用域链的循环，将``outermost = null``，切断引用关系，即从根无法再找到它。



## 2.1 闭包特性应用实例

接下来来看一个利用闭包实现的计数器应用

```js
function counter() {
  var a = 0;

  return {
    counter: function() {
      a++;
    },
    reset() {
      a = 0;
    },
    getValue() {
      console.log(a);
      return a;
    }
  }
}

var c1 = counter();
var c2 = counter();

c1.counter();
c1.counter();
c1.counter();
c1.getValue(); // 3
c1.reset();
c1.getValue(); // 0
c1.counter(); 
c1.getValue(); // 1

var c2 = counter();
c2.counter();
c2.counter();
c2.counter();
c2.counter();
c2.getValue(); // 4

c1.counter();
c1.getValue(); // 2
```

这里我们创建了两个计数器c1和c2，第一个计数器的执行结果情理之中，关键在于c2计数器的执行结果，为什么打印的不是5而是4呢，c1和c2之间为什么可以互相不干扰呢？

**因为每一次函数调用都会创建一个新的执行上下文，即使调用的是同一个函数，并且上一次的调用创建的上下文环境没有被回收。**

上面的代码实际上相当于一个生产定时器的工厂函数，并且生产出来的每个定时器只能通过getValue接口拿到他里面的值。是不是很棒。



黑白分明，再来看一个糟糕的场景

```js
function count() {
  var arr = [];
  for (var i=1; i<=3; i++) {
      arr.push(function () {
          return i * i;
      });
  }
  return arr;
}

var results = count();
var f1 = results[0];
var f2 = results[1];
var f3 = results[2];


log(f1(), f2(), f3()) // 16 16 16
```

看到这里你可能会问，什么鬼？为啥不是1,4,9嘞？

是的，我们的本意是想要输出1,4,9，但是由于js没有块级作用域，所以i这个变量是保存在count这个函数作用域中，当我们调用函数去访问count内的i时，count内的代码早已执行完，并保存的i值为4

好了，我们把上面的变个形再考察一下。

```js
function count() {
  var arr = [];
  for (var i=1; i<=3; i++) {
      arr.push(function () {
          return ++i;
      });
  }
  return arr;
}

var results = count();
var f1 = results[0];
var f2 = results[1];
var f3 = results[2];


log(f1(), f2(), f3())
```

相信有了上面的经验之后，你肯定不会再说结果是2 ,3, 4了。

有可能有人就会说，答案是5, 5, 5

哈哈，实际打印的结果是5, 6, 7。这才是正确答案。

看到这里你可能又要问，这又是什么鬼？说好的函数每次调用都会创建新的作用域，互不干扰的呢？

这里需要看清楚，i变量是存在在count函数作用域中，而不是存在在内部的匿名函数作用域中，而count函数我们只调用了一次，所以i变量对于f1, f2, f3是共享的。

另外还需要注意，return i * i 并没有改改i值， return ++i改变了i值。



上面两个例子如果我们想实现块级作用域的效果，该如何做呢？

很简单，我们只需要再包裹一层函数用来模拟块级作用域就好了

```js
function count() {
  var arr = [];
  for (var i=1; i<=3; i++) {
      arr.push(
        (function(i){
          return function () {
            return ++i;
          }
        })(i)
      );
  }
  return arr;
}

var results = count();
var f1 = results[0];
var f2 = results[1];
var f3 = results[2];


log(f1(), f2(), f3())
```



先讲到这吧，不定期更新...

